# Исправление бага с отображением отпечатка (fingerprint)

## Описание проблемы

Пользователь сообщил о баге, где отпечаток (fingerprint) не отображается в модальном окне проверки безопасности - показывается пустое значение. При этом, если пользователь подтверждает что "коды совпадают" и переходит в чат, диалог работает нормально.

## Причина бага

Проблема заключалась в неправильной синхронизации событий в WebRTC соединении:

1. **Преждевременное событие подключения**: В функции `new_peer()` в `src-tauri/src/webrtc_peer.rs` событие `"ssc-connected"` отправлялось при изменении состояния WebRTC соединения на `Connected`, но это происходило **до** установки криптографического контекста.

2. **Отсутствие криптографического контекста**: Когда фронтенд получал событие `"ssc-connected"` и вызывал `get_fingerprint()`, функция возвращала `None`, поскольку `CRYPTO` контекст еще не был создан.

3. **Гонка условий**: Существовала гонка между установкой WebRTC соединения и обменом криптографическими ключами.

## Исправление

### 1. Удалено преждевременное событие подключения

**До:**
```rust
pc.on_peer_connection_state_change(Box::new(|st: RTCPeerConnectionState| {
    match st {
        RTCPeerConnectionState::Connected => emit_connected(), // ❌ Слишком рано!
        // ...
    }
}));
```

**После:**
```rust
pc.on_peer_connection_state_change(Box::new(|st: RTCPeerConnectionState| {
    match st {
        RTCPeerConnectionState::Connected => {
            // Не отправляем событие подключения здесь, ждем установки криптографического контекста
        },
        // ...
    }
}));
```

### 2. Упрощена логика отправки события

**До:** Сложная логика с проверкой состояния приватного ключа:
```rust
// Отправляем событие подключения только если у нас есть приватный ключ (мы уже отправили свой pub-key)
if MY_PRIV.lock().unwrap().is_none() {
    emit_connected();
} else {
    // Ждем...
}
```

**После:** Простая и надежная логика:
```rust
// Всегда отправляем событие подключения после установки криптографического контекста
emit_connected();
```

### 3. Удалена избыточная проверка в on_open

Убрана дублирующая логика отправки события в обработчике `on_open` data channel.

## Результат

Теперь событие `"ssc-connected"` отправляется **только после** того, как:
1. WebRTC data channel установлен
2. Обменялись публичными ключами
3. Создан криптографический контекст с SAS (fingerprint)

Это гарантирует, что когда фронтенд получает событие и вызывает `get_fingerprint()`, функция всегда вернет корректное значение отпечатка.

## Затронутые файлы

- `src-tauri/src/webrtc_peer.rs` - основное исправление логики событий