# Проблема коллизий nonce в ChaCha20-Poly1305

## Описание проблемы

В текущей реализации криптографического протокола обе стороны используют:
- **Один и тот же ключ** для шифрования и дешифрования
- **Одинаковые счетчики nonce** (0, 1, 2, ...) для обеих сторон

### Схема проблемы:
```
nonce = 0x00000000‖counter_be   (у обоих счётчик 0,1,2…)
key   = один и тот же
```

Если оба участника посылают, например, 3-е сообщение, они шифруют одним ключом и одним nonce — это **нарушает требование ChaCha20-Poly1305** "nonce never repeats per-key".

## Текущий код с проблемой

В файле `src-tauri/src/webrtc_peer.rs`:

```rust
fn build_ctx(peer_pub: &[u8; 32]) -> CryptoCtx {
    // ... генерация общего секрета ...
    
    let hk = Hkdf::<Sha256>::new(None, &shared);
    let mut key = [0u8; 32];
    hk.expand(b"ssc-chat", &mut key).unwrap();
    
    // ПРОБЛЕМА: один и тот же ключ для обеих сторон
    let sealing = aead::LessSafeKey::new(aead::UnboundKey::new(&aead::CHACHA20_POLY1305, &key).unwrap());
    let opening = aead::LessSafeKey::new(aead::UnboundKey::new(&aead::CHACHA20_POLY1305, &key).unwrap());
    
    CryptoCtx { 
        sealing, 
        opening, 
        send_n: 0,  // ПРОБЛЕМА: одинаковые счетчики у обеих сторон
        recv_n: 0,  // ПРОБЛЕМА: одинаковые счетчики у обеих сторон
        sas: sas,
    }
}
```

## Решение: Разделение ключей по направлениям

### Минимальное исправление:

```rust
fn build_ctx(peer_pub: &[u8; 32]) -> CryptoCtx {
    // ... генерация общего секрета ...
    
    // Получаем 64 байта из HKDF
    let hk = Hkdf::<Sha256>::new(None, &shared);
    let mut okm = [0u8; 64];
    hk.expand(b"ssc-chat", &mut okm).unwrap();
    let (k1, k2) = okm.split_at(32);
    
    // Получаем собственный публичный ключ
    let my_pub = get_my_public_key(); // функция для получения собственного pub key
    
    // Детерминированно выбираем ключи на основе публичных ключей
    let (send_key, recv_key) = if my_pub < peer_pub {
        (k1, k2)
    } else {
        (k2, k1)
    };
    
    let sealing = aead::LessSafeKey::new(aead::UnboundKey::new(&aead::CHACHA20_POLY1305, send_key).unwrap());
    let opening = aead::LessSafeKey::new(aead::UnboundKey::new(&aead::CHACHA20_POLY1305, recv_key).unwrap());
    
    CryptoCtx { 
        sealing, 
        opening, 
        send_n: 0, 
        recv_n: 0, 
        sas: sas,
    }
}
```

### Преимущества решения:

1. **Устранение коллизий**: Каждое направление (A→B и B→A) использует свой уникальный ключ
2. **Детерминированность**: Выбор ключей основан на сравнении публичных ключей, гарантируя согласованность
3. **Безопасность**: Разные ключи исключают возможность коллизии nonce
4. **Совместимость**: Не требует изменения протокола handshake

### Альтернативные решения:

1. **Единый счетчик с офсетом**: 
   - Одна сторона использует четные номера (0, 2, 4, ...)
   - Другая сторона использует нечетные номера (1, 3, 5, ...)

2. **Префикс в nonce**: 
   - Добавление уникального префикса для каждой стороны в nonce

**Рекомендация**: Использовать разделение ключей, так как это наиболее простое и надежное решение.

## Статус

- [x] Проблема идентифицирована
- [x] Решение документировано
- [ ] Код исправлен
- [ ] Тесты добавлены